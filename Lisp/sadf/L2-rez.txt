L2.P1
(setf l '(A 2 B 0 C 2 D 0 E 0))
(setf l1 '(A (B) (C (D) (E))))	
(defun inordine(L)
  (cond
    ((null L) nil)
    (T(append 
	(inordine (car (cdr l)))
	(list (car l)) 
	(inordine (car (cddr L)))))
  )
)
L2.P2
(setf l '(A 2 B 0 C 2 D 0 E 0))
(setf l1 '(A (B) (C (D) (E))))
(defun postordine(L)
  (cond
    ((null L) nil)
    (T(append 
	(postordine (car (cdr l)))
	(postordine (car (cddr l)))
	(list (car l)) ))
  )
)

L2.P3
(setf l '(A 2 B 0 C 2 D 0 E 0))
(defun transform(l)
     (cond
       ( (null l) NIL)
       ( (and (not (numberp (car l))) (= (cadr l) 0) (null (cddr l)))
            (cons (car l) '(NIL NIL) ))  
       ( (and (not (numberp (car l))) (= (cadr l) 0))
           (cons (cons (car l) '(NIL NIL) ) (list (transform (cddr l))))) 
       ( (not (numberp (car l))) 
             (cons (car l) (list (transform (cddr l)))))
       ( T (transform (cdr l)))
))
(defun subarbst(l nr)
   (cond
     ( (= nr 0) nil)
     ( (atom l) l)
     ( ( numberp (car l)) (cons (car l) (subarbst (cdr l) nr)))
     ( (and (= nr 1) (= (cadr l) 0)) (list (car l) (cadr l))) 
     ( T (cons (car l) (subarbst (cdr l) (+ (car (cdr l)) (- nr 1)))))
  )
) 
(defun subarbdr(l nr)
   (cond 
     ( (= nr 1) (subarbst l nr))
     ( (atom l) l)
     ( T (subarbdr (cddr l) (+ (car (cdr l)) (- nr 1))))
  )
)
(defun transf(l)
  (cond 
    ( (null l) nil)
    ( (= 0 (cadr l)) (cons (car l) '(nil nil)))
    ( (= 1 (cadr l)) (list (car l) (transf (subarbst (cddr l) '1))))
    ( (= 2 (cadr l)) (list (car l)
                           (transf (subarbst (cddr l) '1))
                           (transf (subarbdr (cddr l) '2))))
  ))
L2.P4
(setf l '(A 2 B 0 C 2 D 0 E 0))
(setf l1 '(A (B) (C (D) (E))))	
(defun Tree (L)
 (Cond
  ( (Null L) Nil)
  ( (zerop (cadr L)) (Append (List (Car L)) '(Nil) '(Nil)) )
  ( (= (Cadr L) 1 ) (Append (List (Car L)) (List (Tree (Cddr L))) '(Nil)) )
  ( (= (Cadr L) 2 ) (Append (List (Car L)) (List (Tree (Cddr L))) 
    (List (Tree (Cdr (Cdddr L))))) ) 
 )
) 
(defun inordine  (L)
 (Cond
  ( (Null L) Nil)
  ( (zerop (cadr L)) (List (Car L)) )
  ( (= (Cadr L) 1 ) (append  (List (Tree (Cddr L))) ) (Car L))
  ( (= (Cadr L) 2 ) (append (List (Tree (Cddr L)))  (Car L) (List (Tree (Cdr (Cdddr L))))) ) 
 )
)

L2.P5
(defun subarb1(l m n)
   (cond
      ((null l) nil)
      ((= m (+ 1 n)) nil)
      (t (append (list (car l)) (list (cadr l))
         (subarb1 (cddr l) (+ m 1) (+ n (cadr l))))
      )
   )
)
(defun subarb2(l m n)
   (cond
     ((null l) nil)
     ((= m (+ 1 n)) l)
     (t (subarb2 (cddr l) (+ m 1) 
        (+ n (cadr l)))
     )
   )
)
(defun afis(l k)
   (cond
     ((null l) nil)
     ((zerop k) (list (car l)))	
     (t (append  (afis (subarb1 (cddr l) 0 0) (- k 1))
              (afis (subarb2 (cddr l) 0 0) (- k 1))) 
     )
   )
)
L2.P6
(setf l '(A 2 B 0 C 2 D 0 E 0))
(setf l1 '(A (B) (C (D) (E))))	
(defun transform(l)
     (cond
       ( (null l) NIL)
       ( (and (not (numberp (car l))) (= (cadr l) 0) (null (cddr l)))
            (cons (car l) '(NIL NIL) ))  
       ( (and (not (numberp (car l))) (= (cadr l) 0))
           (cons (cons (car l) '(NIL NIL) ) (list (transform (cddr l))))) 
       ( (not (numberp (car l))) 
             (cons (car l) (list (transform (cddr l)))))
       ( T (transform (cdr l)))
))
(defun subarbst(l nr)
   (cond
     ( (= nr 0) nil)
     ( (atom l) l)
     ( ( numberp (car l)) (cons (car l) (subarbst (cdr l) nr)))
     ( (and (= nr 1) (= (cadr l) 0)) (list (car l) (cadr l))) 
     ( T (cons (car l) (subarbst (cdr l) (+ (car (cdr l)) (- nr 1)))))
  )
) 
(defun subarbdr(l nr)
   (cond 
     ( (= nr 1) (subarbst l nr))
     ( (atom l) l)
     ( T (subarbdr (cddr l) (+ (car (cdr l)) (- nr 1))))
  )
)
(defun transf(l)
  (cond 
    ( (null l) nil)
    ( (= 0 (cadr l)) (cons (car l) '(nil nil)))
    ( (= 1 (cadr l)) (list (car l) (transf (subarbst (cddr l) '1))))
    ( (= 2 (cadr l)) (list (car l)
                           (transf (subarbst (cddr l) '1))
                           (transf (subarbdr (cddr l) '2))))
  ))
L2.P7
(defun max(a b)
(cond
	((> a b) a)
	(t b)
)
)
(defun adancime(l)
  (cond 
   ((null l) 0)
   ((atom l)  1)
   (t (+ 1 (max (adancime (cadr l)) (adancime (cddr l)) )))
  )
)
(defun echilibrat(a b)
(cond
	( (or (= (- a 1) b) (= (- b 1) a))  "da")
	( (= a b) "da")
	(t "NU")
)
)
(defun arbech(l)
 (echilibrat (adancime (cadr l)) (adancime (cddr l)))
)
L2.P8
(setf l '(A 2 B 0 C 2 D 0 E 0))
(setf l1 '(A (B) (C (D) (E))))	
(defun nod(l k)
  (cond 
	((null l) nil)
	((and (= (cadr L) 0) (= k 1)) (append (car l)))
	((and (= (cadr l) 1) (= k 1)) (append (car l)))
	((and (= (cadr l) 2) (= k 1)) (append (car l)))
	((= (cadr l) 1) (append (list (nod (cddr l) (- k 1)))))
	((= (cadr l) 2) (append (list (nod (cddr l) (- k 1))) (list (nod (cdr (cdddr l)) (- k 1)))))

  )
)
L2.P9
;nr. atomi de la nivel superficial
(defun nr(l)
  (cond
	((null l) 0)
	((atom (car l)) (+ 1 (nr (cdr l) )) )
	( t ( nr(cdr l)) )
  )
)
;lista subargorilor de la nivelul urmator (concatenata)
(defun suba (l)
  (cond
	((null l) nil)
	((not (atom (car l))) (append (car l) (suba(cdr l)) ) )
	( t ( suba(cdr l)) )
  )
)
;nr maxim de noduri de pe nivelul cu numar maxim de noduri
(defun nrmax (l)
   (cond
	((null l) 0)
	((< (nr l) (nrmax (suba l))) (nrmax(suba l)) )
	(t (nr l))
   )
)
;returneaza lista nodurilor de pe nivelul cu nr maxim de noduri
(defun ls (l)
   (cond
	((= (nr l) (nrmax l)) (atomii l) )
	(t (ls (suba l)))
   )
)
;returneaza atomii unei liste
(defun atomii (l)
   (cond 	
	((null l) nil)
	((atom (car l)) (cons (car l) (atomii(cdr l)) ))
	(t (atomii (cdr l)))
   )
)
;returneaza nivelul cu numar maxim de noduri
(defun niv (l)
   (cond 
	((= (nr l) (nrmax l)) 0)
	(t (+ 1 (niv (suba l))))
   )
)
L2.P10
(setf l '(A 2 B 0 C 2 D 0 E 0))
(setf l1 '(A (B) (C (D) (E))))	
(setf l2 '(a (b (c) (d)) (e (f) (g))))
(defun adancime(l)
  (cond 
	((null l) 0)
	(t (+ 1 (max (adancime (cadr l)) (adancime (cddr l)))))
  )
)
(defun echilibrat(l)
  (cond
	((= (adancime (cadr l)) (adancime (car (cddr l)))) 1)
	(t 0)
  )
)
L2.P12
(setf l1 '(A (B) (C (D) (E))))	
(setf l2 '(a (b (c) (d)) (e (f) (g))))
(defun adancime(l)
  (cond 
	((null l) 0)
	(t (+ 1 (max (adancime (cadr l)) (adancime (cddr l)))))
  )
)
(defun lista_niv(l k)
  (cond
	((= k 1) (list (car l)))
	(t (append (lista_niv (cadr l) (- k 1)) (lista_niv (car (cddr l)) (- k 1))))
  )
)
(setf h (adancime l))
(defun nr_max(l h)
  (cond
	((= h 0) nil)
	(t (max 
	     (length (lista_niv l h)) 
	     (max 
		(length (lista_niv (cadr l) (- h 1))) 
		(length (lista_niv (car (cddr l)) (- h 1)))
	     )		
	   )
	)
	
  )
)
(defun lista_max(l h)
  (cond
	((= h 0) nil)
	((> (length (lista_niv l h)) 
	    (max 
		(length (lista_niv (cadr l) (- h 1))) 
		(length (lista_niv (car (cddr l)) (- h 1)))
	    )
	 )
	 (lista_niv l h)
	)		
	((> (length (lista_niv (cadr l) (- h 1))) 
	    (length (lista_niv (car (cddr l)) (- h 1)))
	 )
	 (lista_niv (cadr l) (- h 1))
	)
	(t (lista_niv (car (cddr l)) (- h 1))) 
  )
)
